const rgb2Hex = (r, g, b, a) => {
    let computedR = r.toString(16);
    let computedG = g.toString(16);
    let computedB = b.toString(16);
    let computedA = Math.round(+a * 255).toString(16);

    if (computedR.length === 1)
        computedR = "0" + computedR;
    if (computedG.length === 1)
        computedG = "0" + computedG;
    if (computedB.length === 1)
        computedB = "0" + computedB;
    if (computedA.length === 1)
        computedA = "0" + computedA;

    return "#" + computedR + computedG + computedB;
}

const cmyk2rgba = cmykColor => {
    if (!/^cmyk\(\s?(\d{1,3}%?,\s?){4}\)$/.test(cmykColor)) {
        return cmykColor;
    }

    let cmykArray = cmykColor.replace(/cmyk\(|\)|%/gm, "").split(',')
    cmykArray = cmykArray.map(el => parseInt(el / 100, 10));


    const a = -cmykArray[0]
    const r = 255 * (1 - cmykArray[1]) * (1 - cmykArray[4]);
    const g = 255 * (1 - cmykArray[2]) * (1 - cmykArray[4]);
    const b = 255 * (1 - cmykArray[3]) * (1 - cmykArray[4]);

    if (validateRGBA(r, g, b, a)) {
        return `rgba(${r}, ${g}, ${b}, ${r}, ${a})`;
    }

    return cmykColor;
}

const rgb2cmyk = (r, g, b) => {
    let computedC = 0;
    let computedM = 0;
    let computedY = 0;
    let computedK = 0;

    //remove spaces from input RGB values, convert to int
    r = parseInt(('' + r).replace(/\s/g, ''), 10);
    g = parseInt(('' + g).replace(/\s/g, ''), 10);
    b = parseInt(('' + b).replace(/\s/g, ''), 10);

    // BLACK
    if (r === 0 && g === 0 && b === 0) {
        computedK = 1;
        return [0, 0, 0, 1];
    }

    computedC = 1 - (r / 255);
    computedM = 1 - (g / 255);
    computedY = 1 - (b / 255);

    const minCMY = Math.min(computedC, Math.min(computedM, computedY));
    computedC = Math.round((computedC - minCMY) / (1 - minCMY) * 100);
    computedM = Math.round((computedM - minCMY) / (1 - minCMY) * 100);
    computedY = Math.round((computedY - minCMY) / (1 - minCMY) * 100);
    computedK = Math.round(minCMY * 100);

    return "cmyk( " + computedC + "%, " + computedM + "%, " + computedY + "%, " + computedK + "%)";
}

const rgb2Hsv = (r, g, b, a) => {
    const computedR = r / 255;
    const computedG = g / 255;
    const computedB = b / 255;

    const max = Math.max(computedR, computedG, computedB);
    const min = Math.min(computedR, computedG, computedB);
    const delta = max - min;

    let h = 0;
    const s = max === 0 ? 0 : Math.round(delta * 100 / max);
    const v = Math.round(max * 100);

    if (max === min) {
        h = 0; // achromatic
    } else {
        switch (max) {
            case computedR:
                h = Math.round((g < b ? 6 : 0) + (g - b) / delta);
                break;
            case computedG:
                h = Math.round(2 + (b - r) / delta);
                break;
            case computedB:
                h = Math.round(4 + (r - g) / delta);
                break;
            default:
                break
        }
        h = h * 60;
    }
    return "hsva( " + h + ", " + s + "%, " + v + "%, " + a + ")";
}

const rgb2Hsl = (r, g, b, a) => {
    const computedR = r / 255;
    const computedG = g / 255;
    const computedB = b / 255;

    const max = Math.max(computedR, computedG, computedB);
    const min = Math.min(computedR, computedG, computedB);
    const delta = max - min;

    let h = 0;
    let s = 0;
    let l = 0;


    if (delta === 0) h = 0;
    else if (max === computedR) h = ((computedG - computedB) / delta) % 6;
    else if (max === computedG) h = (computedB - computedR) / delta + 2;
    else h = (computedR - computedG) / delta + 4;

    h = Math.round(h * 60);

    if (h < 0) h += 360;
    l = (max + min) / 2;
    s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));

    s = +(s * 100).toFixed();
    l = +(l * 100).toFixed();

    return "hsla( " + h + ", " + s + "%, " + l + "%, " + a + ")";
}

const hex2rgba = hexColor => {
    let c;

    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hexColor)) {
        c = hexColor.substring(1).split('');
        if (c.length === 3) {
            c = [c[0], c[0], c[1], c[1], c[2], c[2]];
        }
        c = '0x' + c.join('');
        return 'rgba( ' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(', ') + ', 1)';
    }

    return hexColor;
}

const hsla2rgba = hslaColor => {
    if (!/^hsla\(\s?(\d{1,3}%?,\s?){3}(1|0)\.?(\d+)?\)$/.test(hslaColor)) {
        return hslaColor;
    }

    let hslaArray = hslaColor.replace(/hsla\(|\)|%/gm, "").split(',')

    hslaArray = hslaArray.map(el => parseInt(el, 10));

    let r;
    let g;
    let b;


    let h = hslaArray[0]
    let s = hslaArray[1]
    let l = hslaArray[2]
    let a = hslaArray[3]

    var m, c, x

    if (!isFinite(h)) h = 0
    if (!isFinite(s)) s = 0
    if (!isFinite(l)) l = 0

    h /= 60
    if (h < 0) h = 6 - (-h % 6)
    h %= 6

    s = Math.max(0, Math.min(1, s / 100))
    l = Math.max(0, Math.min(1, l / 100))

    c = (1 - Math.abs((2 * l) - 1)) * s
    x = c * (1 - Math.abs((h % 2) - 1))

    if (h < 1) {
        r = c
        g = x
        b = 0
    } else if (h < 2) {
        r = x
        g = c
        b = 0
    } else if (h < 3) {
        r = 0
        g = c
        b = x
    } else if (h < 4) {
        r = 0
        g = x
        b = c
    } else if (h < 5) {
        r = x
        g = 0
        b = c
    } else {
        r = c
        g = 0
        b = x
    }

    m = l - c / 2
    r = Math.round((r + m) * 255)
    g = Math.round((g + m) * 255)
    b = Math.round((b + m) * 255)


    if (validateRGBA(r, g, b, a)) {
        return `rgba(${r}, ${g}, ${b}, ${a})`;
    }

    return hslaColor;
}

const validateRGBA = (r, g, b, a) => {
    console.log(r, g, b, a)

    if (r === null || g === null || b === null || a === null ||
        isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
        return false;
    }

    if (r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255) {
        return false;
    }

    return true
}


const hsva2rgba = hsvaColor => {

    let hslaArray = hsvaColor.replace(/hsva\(|\)|%/gm, "").split(',')
    hslaArray = hslaArray.map(el => parseInt(el / 100, 10));

    let r;
    let g;
    let b;


    let h = hslaArray[0]
    let s = hslaArray[1]
    let v = hslaArray[2]
    let a = hslaArray[3]



    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0:
            r = v;
            g = t;
            b = p;
            break;
        case 1:
            r = q;
            g = v;
            b = p;
            break;
        case 2:
            r = p;
            g = v;
            b = t;
            break;
        case 3:
            r = p;
            g = q;
            b = v;
            break;
        case 4:
            r = t;
            g = p;
            b = v;
            break;
        case 5:
            r = v;
            g = p;
            b = q;
            break;
        default:
            break;
    }

    if (validateRGBA(r, g, b, a)) {
        return `rgba(${r * 255}, ${g * 255}, ${b * 255}, ${a})`;
    }

    return hsvaColor;
}

const calculateColorSystem = color => {
    if (color.startsWith('rgba')) return 'rgba';
    if (color.startsWith('cmyk')) return 'cmyk';
    if (color.startsWith('hsla')) return 'hsla';
    if (color.startsWith('#')) return 'hex';
    if (color.startsWith('hsva')) return 'hsva';

}

const convert2rgba = color => {
    let rgbaColor;
    const colorSystem = calculateColorSystem(color);

    calculateColorSystem(color)

    switch (colorSystem) {
        case "rgba":
            rgbaColor = color;
            break;
        case "cmyk":
            rgbaColor = cmyk2rgba(color);
            break;
        case "hex":
            rgbaColor = hex2rgba(color);
            break;
        case "hsla":
            rgbaColor = hsla2rgba(color);

            break;
        case "hsva":
            rgbaColor = hsva2rgba(color);
            break;
        default:
            break;
    }

    console.log(rgbaColor)

    return rgbaColor;
}

const getAllColorSystemValues = rgbaColor => {
    let rgbaArray = rgbaColor.replace('rgba(', '').replace(')', '').split(',')
    rgbaArray = rgbaArray.map(el => parseInt(el, 10));

    const hex = rgb2Hex(rgbaArray[0], rgbaArray[1], rgbaArray[2], rgbaArray[3]);
    const cmyk = rgb2cmyk(rgbaArray[0], rgbaArray[1], rgbaArray[2], rgbaArray[3]);
    const hsla = rgb2Hsl(rgbaArray[0], rgbaArray[1], rgbaArray[2], rgbaArray[3]);
    const hsva = rgb2Hsv(rgbaArray[0], rgbaArray[1], rgbaArray[2], rgbaArray[3]);

    return { hex, cmyk, hsla, hsva, rgba: rgbaColor }
}

const readColorOpacity = rgbaColor => {
    const rgbaArray = rgbaColor.replace('rgba(', '').replace(')', '').split(',');
    let opacity = parseFloat(rgbaArray[3]) || 1;

    if (opacity > 1) {
        return opacity = 1;
    }

    if (opacity < 0) {
        return opacity = 0;
    }

    return opacity;
}

export { rgb2Hex, rgb2Hsl, rgb2Hsv, rgb2cmyk, cmyk2rgba, convert2rgba, getAllColorSystemValues, readColorOpacity }