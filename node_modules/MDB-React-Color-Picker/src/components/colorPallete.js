import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';

class ColorPallete extends PureComponent {
    canvasRef = React.createRef();
    pickerRef = React.createRef()
    canvas = null;
    drag = false;

    componentDidMount = () => {
        this.drawGradient();

        document.addEventListener('mouseup', this.dragStop);
    }

    componentWillUnmount = () => {
        document.removeEventListener('mouseup', this.dragStop);
    }

    componentDidUpdate = () => {
        this.drawGradient()
    }

    drawGradient = () => {
        this.canvas = this.canvasRef.current.getContext("2d");
        this.canvas.fillStyle = this.props.palleteRgbaColor;
        this.canvas.fillRect(0, 0, this.props.palleteWidth, this.props.palleteHeight)

        const grdWhite = this.canvas.createLinearGradient(0, 0, this.props.palleteWidth, 0);
        grdWhite.addColorStop(0, 'rgb(255,255,255)');
        grdWhite.addColorStop(1, 'transparent');
        this.canvas.fillStyle = grdWhite;
        this.canvas.fillRect(0, 0, this.props.palleteWidth, this.props.palleteHeight);

        const grdBlack = this.canvas.createLinearGradient(0, 0, 0, this.props.palleteHeight);
        grdBlack.addColorStop(0, 'transparent');
        grdBlack.addColorStop(1, 'rgb(0,0,0)');
        this.canvas.fillStyle = grdBlack;
        this.canvas.fillRect(0, 0, this.props.palleteWidth, this.props.palleteHeight);
    }

    updateSelectedColor = e => {
        e.persist();

        const x = e.nativeEvent.offsetX;
        const y = e.nativeEvent.offsetY;

        const palleteData = this.canvas.getImageData(x, y, 1, 1).data;
        const rgbaColor = `rgba(${palleteData[0]}, ${palleteData[1]}, ${palleteData[2]}, ${this.props.opacity})`;

        this.props.updateSelectedColor(rgbaColor, x, y);
    }

    onMouseDownHandler = e => {
        this.drag = true;
        this.canvasRef.current.style.cursor = 'none';

        this.updateSelectedColor(e);
    }

    onMouseMoveHandler = e => {
        if (this.drag) {
            this.updateSelectedColor(e);
        }
    }

    dragStop = () => {
        this.drag = false;
        this.canvasRef.current.style.cursor = 'crosshair';
    }

    render() {
        return (
            <div className="mdb-cp-color-palette" >
                <div ref={this.pickerRef} className="mdb-cp-picker" style={{ left: this.props.x + 'px', top: this.props.y + 'px', background: this.props.selectedColor }} ></ div>
                <canvas
                    ref={this.canvasRef}
                    height={this.props.palleteHeight}
                    width={this.props.palleteWidth}
                    className="mdb-cp-palette"

                    onDragStart={() => false}
                    onDrag={() => false}
                    onMouseDown={this.onMouseDownHandler}
                    onTouchStart={this.onMouseDownHandler}
                    onMouseMove={this.onMouseMoveHandler}
                    onTouchMove={this.onMouseMoveHandler}
                    onMouseUp={this.onMouseUpHandler}
                    onTouchEnd={this.onMouseUpHandler}
                >
                </canvas>
            </div>
        );
    }
};


ColorPallete.defaultProps = {

    palleteRgbaColor: 'rgba( 255, 0, 0, 1)'
}

ColorPallete.propTypes = {
    palleteRgbaColor: PropTypes.string.isRequired,
    palleteWidth: PropTypes.number.isRequired,
    palleteHeight: PropTypes.number.isRequired,
    opacity: PropTypes.number.isRequired,
    selectedColor: PropTypes.string.isRequired,
    updateSelectedColor: PropTypes.func.isRequired,
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
}

export default ColorPallete;